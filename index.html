<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Falling Objects Game - –ó–∞ Dessi –∏ Eva | 100 –ù–∏–≤–∞</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 36px;
        }

        .subtitle {
            text-align: center;
            color: #999;
            margin-bottom: 30px;
            font-size: 14px;
        }

        #gameCanvas {
            display: block;
            background: #1a1a2e;
            border: 3px solid #667eea;
            border-radius: 10px;
            margin: 20px auto;
            width: 100%;
            max-width: 800px;
            height: 500px;
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        #btnStart {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 14px 32px;
            font-size: 18px;
        }

        #btnStart:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        #btnPause, #btnResume, #btnStop {
            background: #f39c12;
            color: white;
        }

        #btnPause:hover, #btnResume:hover, #btnStop:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        #btnMusic {
            background: #9b59b6;
            color: white;
        }

        #btnMusic:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 20px 0;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
        }

        .stat {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
        }

        .progress-bar {
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.2s;
        }

        .hint {
            text-align: center;
            color: #666;
            font-size: 13px;
            margin-top: 20px;
            line-height: 1.8;
        }

        .hint strong {
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ FALLING OBJECTS GAME</h1>
        <div class="subtitle">–ó–∞ Dessi –∏ Eva | 100 –ù–∏–≤–∞ ‚Ä¢ –ú—É–∑–∏–∫–∞ ‚Ä¢ 5 –¢–µ–º–∏ ‚Ä¢ –ï–º–æ–¥–∑–∏</div>

        <canvas id="gameCanvas" width="800" height="500"></canvas>
    <audio id="bgMusic" src="music.mp3" loop crossorigin="anonymous"></audio>

        <div class="controls">
            <button id="btnStart">‚ñ∂Ô∏è START</button>
            <button id="btnPause">‚è∏Ô∏è PAUSE</button>
            <button id="btnResume">‚ñ∂Ô∏è RESUME</button>
            <button id="btnStop">‚èπÔ∏è STOP</button>
            <button id="btnMusic">üîä MUSIC: ON</button>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">–ù–∏–≤–æ</div>
                <div class="stat-value"><span id="level">1</span>/100</div>
            </div>
            <div class="stat">
                <div class="stat-label">–û–±–µ–∫—Ç–∏</div>
                <div class="stat-value" id="objects">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">–í—Ä–µ–º–µ</div>
                <div class="stat-value"><span id="time">0</span>s</div>
            </div>
            <div class="stat">
                <div class="stat-label">–ü—Ä–æ–≥—Ä–µ—Å</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress"></div>
                </div>
            </div>
        </div>

        <div class="hint">
            <strong>‚å®Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> ‚Üê ‚Üí –∏–ª–∏ A/D –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ<br>
            <strong>üéØ –¶–µ–ª:</strong> –°—ä–±–µ—Ä–∏ –µ–º–æ–¥–∑–∏ | –í—Å—è–∫–æ –Ω–∏–≤–æ ‚Üí –ø–æ-—Ç—Ä—É–¥–Ω–æ | –î–æ—Å—Ç–∏–≥–Ω–∏ –Ω–∏–≤–æ 100!<br>
            <strong>üéµ –ú—É–∑–∏–∫–∞:</strong> –ù–∞—Ç–∏—Å–Ω–∏ MUSIC –±—É—Ç–æ–Ω | <strong>–í—Ä–µ–º–µ:</strong> 25 —Å–µ–∫ –∑–∞ –Ω–∏–≤–æ
        </div>
    </div>

    <script>
        // ============ GAME CONFIG ============
        const config = {
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 500,
            LEVEL_DURATION: 25,
            MAX_LEVELS: 100,
            // make player bar smaller as requested
            PLAYER_WIDTH: 80,
            PLAYER_HEIGHT: 14,
            PLAYER_SPEED: 420,
            PLAYER_Y: 460,
            // spawning tuning: start easier (bigger interval) and get faster with level
            SPAWN_INTERVAL_START: 1.5, // seconds between spawns at level 0
            SPAWN_INTERVAL_MIN: 0.12, // fastest spawn interval
            SPAWN_INTERVAL_DEC_PER_LEVEL: 0.015, // decrease per level
            // object speed tuning
            OBJECT_BASE_SPEED: 40, // px/sec at level 0
            OBJECT_SPEED_PER_LEVEL: 2.5 // added per level
        };

        // ============ GAME STATE ============
        const game = {
            canvas: document.getElementById("gameCanvas"),
            ctx: null,
            running: false,
            paused: false,
            statusMessage: "",
            level: 0,
            time: 0,
            objects: [],
            player: { 
                x: config.CANVAS_WIDTH / 2, 
                y: config.PLAYER_Y,
                w: config.PLAYER_WIDTH,
                h: config.PLAYER_HEIGHT,
                color: "#22e246"
            },
            keys: {},
            musicMuted: false,
            audioContext: null,
            spawnTimer: 0,
            lastFrameTime: 0,
            animationId: 0
        };

        game.ctx = game.canvas.getContext("2d");

        // ============ THEMES & EMOJIS ============
        const themes = [
            { id: 0, name: "Night", bg1: "#020617", bg2: "#020b3d", emojis: ["üê∂", "üê±", "ü¶ä", "üêª", "üê∞", "ü¶Å", "üêº"] },
            { id: 1, name: "Day", bg1: "#9ad9ff", bg2: "#e9f7ff", emojis: ["üçé", "üçä", "üçã", "üçå", "üçâ", "üçì", "üåª"] },
            { id: 2, name: "Factory", bg1: "#2b103e", bg2: "#7e3ff2", emojis: ["üîß", "üõ†", "‚öô", "üî©", "ü™ö", "üî®", "ü™õ"] },
            { id: 3, name: "Ocean", bg1: "#1a5f7a", bg2: "#0d4a63", emojis: ["üê†", "üêü", "üê°", "ü¶à", "üêô", "ü¶ë", "üêö"] },
            { id: 4, name: "Space", bg1: "#000011", bg2: "#0a0033", emojis: ["‚≠ê", "üåü", "‚ú®", "üí´", "üîÜ", "ü™ê", "üõ∏"] }
        ];

        // ============ UTILITIES ============
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function getTheme(level) {
            return themes[level % themes.length];
        }

        function randomEmoji(level) {
            const theme = getTheme(level);
            return theme.emojis[randomInt(0, theme.emojis.length - 1)];
        }

        // ============ BACKGROUND ============
        function drawBackground() {
            const theme = getTheme(game.level);
            const grad = game.ctx.createLinearGradient(0, 0, 0, config.CANVAS_HEIGHT);
            grad.addColorStop(0, theme.bg1);
            grad.addColorStop(1, theme.bg2);
            
            game.ctx.fillStyle = grad;
            game.ctx.fillRect(0, 0, config.CANVAS_WIDTH, config.CANVAS_HEIGHT);

            // Stars for night theme
            if (game.level % 5 === 0) {
                game.ctx.fillStyle = "#ffffff";
                for (let i = 0; i < 30; i++) {
                    const x = Math.sin(i * 2) * 200 + i * 15;
                    const y = Math.cos(i * 3) * 150 + i * 10;
                    game.ctx.beginPath();
                    game.ctx.arc(x % config.CANVAS_WIDTH, y % config.CANVAS_HEIGHT, 1.5, 0, Math.PI * 2);
                    game.ctx.fill();
                }
            }
        }

        // ============ CREATE FALLING OBJECT ============
        function createObject() {
            // speed increases linearly with level for predictable difficulty
            const speed = config.OBJECT_BASE_SPEED + game.level * config.OBJECT_SPEED_PER_LEVEL + random(-10, 10);
            const x = random(24, config.CANVAS_WIDTH - 24);

            return {
                x: x,
                y: -40,
                emoji: randomEmoji(game.level),
                speed: speed,
                size: 28
            };
        }

        // ============ UPDATE ============
        function update(dt) {
            game.time += dt;

            // Check level complete - advance regardless of remaining objects
            if (game.time >= config.LEVEL_DURATION) {
                game.level++;
                if (game.level >= config.MAX_LEVELS) {
                    game.running = false;
                    alert("üéâ –ü–û–ó–î–†–ê–í–õ–ï–ù–ò–Ø! –ó–∞–≤—ä—Ä—à–∏ –≤—Å–∏—á–∫–∏ 100 –Ω–∏–≤–∞! üéâ");
                } else {
                    // reset timer and clear objects for next level
                    game.time = 0;
                    game.objects = [];
                }
            }

            // Spawn objects using a timer: start easy (long interval) and speed up with levels
            game.spawnTimer += dt;
            const spawnInterval = Math.max(config.SPAWN_INTERVAL_MIN, config.SPAWN_INTERVAL_START - game.level * config.SPAWN_INTERVAL_DEC_PER_LEVEL);
            if (game.spawnTimer >= spawnInterval) {
                // spawn count increases slowly with level
                const spawnCount = Math.min(4, 1 + Math.floor(game.level / 25));
                for (let s = 0; s < spawnCount; s++) {
                    game.objects.push(createObject());
                }
                game.spawnTimer -= spawnInterval;
            }

            // Limit max objects on screen for performance
            const MAX_OBJECTS = 30;
            if (game.objects.length > MAX_OBJECTS) {
                game.objects.splice(0, game.objects.length - MAX_OBJECTS);
            }

            // Update player
            const moveSpeed = config.PLAYER_SPEED;
            if (game.keys["ArrowLeft"] || game.keys["a"] || game.keys["A"]) {
                game.player.x -= moveSpeed * dt;
            }
            if (game.keys["ArrowRight"] || game.keys["d"] || game.keys["D"]) {
                game.player.x += moveSpeed * dt;
            }
            if (game.keys["ArrowUp"] || game.keys["w"] || game.keys["W"]) {
                game.player.y -= moveSpeed * dt;
            }
            if (game.keys["ArrowDown"] || game.keys["s"] || game.keys["S"]) {
                game.player.y += moveSpeed * dt;
            }

            // Clamp player
            game.player.x = Math.max(game.player.w / 2, Math.min(config.CANVAS_WIDTH - game.player.w / 2, game.player.x));
            game.player.y = Math.max(game.player.h / 2, Math.min(config.CANVAS_HEIGHT - game.player.h / 2, game.player.y));

            // Update objects and collision
            for (let i = game.objects.length - 1; i >= 0; i--) {
                const obj = game.objects[i];
                obj.y += obj.speed * dt;

                // Collision
                if (obj.y > game.player.y - 30 &&
                    obj.y < game.player.y + game.player.h &&
                    obj.x > game.player.x - game.player.w / 2 &&
                    obj.x < game.player.x + game.player.w / 2) {
                    // Collision with player -> GAME OVER
                    game.running = false;
                    game.statusMessage = "GAME OVER";
                    // stop background music if playing
                    try { document.getElementById('bgMusic').pause(); document.getElementById('bgMusic').currentTime = 0; } catch(e) {}
                    // play a short low buzz
                    playSound(120, 300, 0.25);
                    break;
                } else if (obj.y > config.CANVAS_HEIGHT) {
                    game.objects.splice(i, 1);
                }
            }
        }

        // ============ DRAW ============
        function draw() {
            drawBackground();

            // Draw objects
            game.ctx.font = "32px Arial";
            game.ctx.textAlign = "center";
            game.ctx.textBaseline = "middle";
            game.objects.forEach(obj => {
                game.ctx.fillText(obj.emoji, obj.x, obj.y);
            });

            // Draw player
            game.ctx.fillStyle = game.player.color;
            game.ctx.fillRect(
                game.player.x - game.player.w / 2,
                game.player.y - game.player.h / 2,
                game.player.w,
                game.player.h
            );
            game.ctx.strokeStyle = "#fff";
            game.ctx.lineWidth = 2;
            game.ctx.strokeRect(
                game.player.x - game.player.w / 2,
                game.player.y - game.player.h / 2,
                game.player.w,
                game.player.h
            );
            // If there is a status message (e.g., GAME OVER), draw overlay
            if (game.statusMessage) {
                game.ctx.fillStyle = 'rgba(0,0,0,0.6)';
                game.ctx.fillRect(0, 0, config.CANVAS_WIDTH, config.CANVAS_HEIGHT);

                game.ctx.fillStyle = '#fff';
                game.ctx.textAlign = 'center';
                game.ctx.textBaseline = 'middle';
                game.ctx.font = '64px Arial';
                game.ctx.fillText(game.statusMessage, config.CANVAS_WIDTH / 2, config.CANVAS_HEIGHT / 2 - 20);

                game.ctx.font = '20px Arial';
                game.ctx.fillText('–ù–∞—Ç–∏—Å–Ω–∏ START –∑–∞ –∏–≥—Ä–∞ –æ—Ç–Ω–∞—á–∞–ª–æ', config.CANVAS_WIDTH / 2, config.CANVAS_HEIGHT / 2 + 30);
            }
        }

        // ============ GAME LOOP ============
        function gameLoop(timestamp) {
            if (!game.lastFrameTime) game.lastFrameTime = timestamp;
            const deltaTime = (timestamp - game.lastFrameTime) / 1000;
            game.lastFrameTime = timestamp;

            if (game.running && !game.paused) {
                update(deltaTime);
            }

            draw();

            // Update HUD
            document.getElementById("level").textContent = game.level + 1;
            document.getElementById("objects").textContent = game.objects.length;
            document.getElementById("time").textContent = game.time.toFixed(1);
            document.getElementById("progress").style.width = ((game.time / config.LEVEL_DURATION) * 100) + "%";

            if (game.running) {
                game.animationId = requestAnimationFrame(gameLoop);
            }
        }

        // ============ AUDIO ============
        function initAudio() {
            if (!game.audioContext) {
                game.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(freq, duration, volume) {
            initAudio();
            try {
                const now = game.audioContext.currentTime;
                const osc = game.audioContext.createOscillator();
                const gain = game.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(game.audioContext.destination);
                osc.frequency.value = freq;
                
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);
                
                osc.start(now);
                osc.stop(now + duration / 1000);
            } catch (e) {}
        }

        // Background music: external file `music.mp3` loaded into audio element
        const bgAudio = document.getElementById('bgMusic');

        function startBgAudio() {
            if (!bgAudio) return;
            try {
                bgAudio.volume = 0.9;
                const p = bgAudio.play();
                if (p && p.catch) p.catch(e => console.warn('bgAudio play blocked', e));
            } catch (e) {}
        }

        function pauseBgAudio() {
            try { if (bgAudio) bgAudio.pause(); } catch (e) {}
        }

        function stopBgAudio() {
            try { if (bgAudio) { bgAudio.pause(); bgAudio.currentTime = 0; } } catch (e) {}
        }

        // ============ CONTROLS ============
        document.getElementById("btnStart").addEventListener("click", () => {
            // ensure clean start
            if (game.animationId) cancelAnimationFrame(game.animationId);
            game.running = true;
            game.paused = false;
            game.level = 0;
            game.time = 0;
            game.objects = [];
            game.lastFrameTime = 0;
            game.statusMessage = "";

            if (!game.musicMuted) {
                startBgAudio();
            }

            game.animationId = requestAnimationFrame(gameLoop);
        });

        document.getElementById("btnPause").addEventListener("click", () => {
            if (game.running) {
                game.paused = true;
                pauseBgAudio();
            }
        });

        document.getElementById("btnResume").addEventListener("click", () => {
            if (game.paused) {
                game.paused = false;
                if (!game.musicMuted) {
                    startBgAudio();
                }
                // resume loop if needed
                if (!game.animationId) game.animationId = requestAnimationFrame(gameLoop);
            }
        });

        document.getElementById("btnStop").addEventListener("click", () => {
            game.running = false;
            game.paused = false;
            cancelAnimationFrame(game.animationId);
            game.objects = [];
            game.level = 0;
            game.time = 0;
            game.lastFrameTime = 0;
            stopBgAudio();
            game.statusMessage = "";
            game.ctx.clearRect(0, 0, config.CANVAS_WIDTH, config.CANVAS_HEIGHT);
            drawBackground();
        });

        document.getElementById("btnMusic").addEventListener("click", function() {
            game.musicMuted = !game.musicMuted;
            if (game.musicMuted) {
                this.textContent = "üîá MUSIC: OFF";
                pauseBgAudio();
            } else {
                this.textContent = "üîä MUSIC: ON";
                if (game.running) {
                    startBgAudio();
                }
            }
        });

        // Keyboard controls
        window.addEventListener("keydown", e => {
            game.keys[e.key] = true;
        });

        window.addEventListener("keyup", e => {
            game.keys[e.key] = false;
        });

        // Pointer controls (mouse, touch, pen) - support dragging to move both X and Y
        let pointerActive = false;

        function pointerToCanvasCoords(e) {
            const rect = game.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (config.CANVAS_WIDTH / rect.width);
            const y = (e.clientY - rect.top) * (config.CANVAS_HEIGHT / rect.height);
            return { x, y };
        }

        game.canvas.addEventListener('pointerdown', e => {
            pointerActive = true;
            game.canvas.setPointerCapture && game.canvas.setPointerCapture(e.pointerId);
            const p = pointerToCanvasCoords(e);
            game.player.x = p.x;
            game.player.y = p.y;
        });

        window.addEventListener('pointerup', e => {
            pointerActive = false;
            try { game.canvas.releasePointerCapture && game.canvas.releasePointerCapture(e.pointerId); } catch (err) {}
        });

        game.canvas.addEventListener('pointermove', e => {
            const p = pointerToCanvasCoords(e);
            // If dragging (pointer down) or it's a touch/pen, move both X and Y
            if (pointerActive || e.pointerType === 'touch' || e.pointerType === 'pen') {
                game.player.x = p.x;
                game.player.y = p.y;
            } else {
                // hover with mouse - keep horizontal control as before
                game.player.x = p.x;
            }
        }, { passive: true });

        // Initial draw
        drawBackground();
        console.log("‚úÖ –ò–≥—Ä–∞ –∑–∞—Ä–µ–¥–µ–Ω–∞! –ù–∞—Ç–∏—Å–Ω–∏ START –∑–∞ –Ω–∞—á–∞–ª–æ");
    </script>
</body>
</html>
